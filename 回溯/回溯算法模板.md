# 9.10-回溯算法

## 回溯算法模板

所有的回溯算法都可以抽象成一颗 N叉树，我们使用循环去处理树的兄弟节点，用递归来处理子节点相关的问题。分别对应我们抽象概念里面的广度和深度。

回溯法的本质其实就是**暴力查找**，但是可以配合减枝（也就是对特定分支通过条件判断提前结束循环）来减少复杂度。

```
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

从问题种类我们可以把回溯问题分为以下一个种类：

* 组合

* 分割

* 子集

* 排列

* 棋盘问题

* 其他

下面我们就这些种类和例题，进行回溯相关知识点的学习，力求在一个学习周期内完全掌握。

## 组合问题

![](https://media.heptabase.com/v1/images/8fe44ff0-2b44-4609-9207-e510910f3e42/370beb5d-2f3b-4a9b-9596-808eaabfbe15/image.png)

我们把组合问题抽象成一棵树的话，这个问题可以抽象如下：

![](https://media.heptabase.com/v1/images/8fe44ff0-2b44-4609-9207-e510910f3e42/45252cc0-838d-4658-ad1c-d8b7a4d34f52/image.png)

分析可知，n 相当于我们树中的宽度，k 则为深度。

我们从根节点出发，走两步就到了叶子节点，路径则为一个结果子集，走的过程中 n 会逐渐减少（因为取完的数不能重复拿）。

这个问题就可以拆分成两个问题：

* 如何确定每轮遍历的宽度，即 n 的值

我们定义一个边界指针 startindex ，每次递归后就加 1。

比如把 1 取出来之后，我们下一轮要在 2，3, 4三个数中去取，则需要让遍历的起始值从第一个变成第二个。

* 如何确定终止条件

当临时结果变量 temp 长度等于 k 的时候，则表示到了叶子节点，可以保存并返回了。

于是我们可以得到如下代码:

```javascript
var combine = function (n, k) {
    let res = []
    let temp = []
    var getLeaf = (n, k, startindex) => {
        if (k == temp.length) {
            res.push(temp.slice())
            return
        }
        for (let i = startindex; i < n; i++) {
            temp.push(i+1)
            getLeaf(n, k, i+1)
            //
            temp.pop()
        }
    }
    getLeaf(n, k, 0)
    return res
};
```

 代码中的 temp.pop() 相当于把状态重置回去，相当于走了一步后，把应该的保留的状态往下存，存完需要回到上一步。

由于我们从始至终都用的一个 temp 变量，所以每次存值的时候都需要用 slice 去存一个浅拷贝，否则因为引用类型都会变成空数组